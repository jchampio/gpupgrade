#! /bin/bash
#
# A version of gpinitsystem that caches the last created cluster. Cache is hit
# if, and only if, all of the following are true:
#
# - The arguments passed to gpinitsystem are identical to the last run.
# - The -a option to gpinitsystem is used (to avoid prompts).
# - The -I input option to gpinitsystem is used, and the contents of that file
#   are identical to the last run.
#
# BUGS:
# - Mirrors are ignored. This only works for upgrade scenarios.
#

set -o errexit
set -o pipefail
set -o nounset

CACHEDIR=/tmp/gpinitsystem.cache
mkdir -p "$CACHEDIR"

HASHPROG=
if command -v shasum; then
    HASHPROG=shasum
elif command -v sha1sum; then
    HASHPROG=sha1sum
elif command -v md5sum; then
    HASHPROG=md5sum
fi

log() {
    echo "$@" >> "$CACHEDIR/log"
}

datadir() {
    echo "$@" | cut -d~ -f3
}

cache() {
    local cachedir=$1
    local datadir=$2

    local subdir="$cachedir/$datadir"
    mkdir -p "$subdir"

    cp -pR "$datadir"/ "$subdir"
}

cache_cluster() {
    local inputfile="$1"
    local cache="$2"

    # Clear out any previous caches.
    rm -rf "$CACHEDIR"/cache.*

    source "$inputfile"
    local master_datadir="$(datadir $QD_PRIMARY_ARRAY)"

    # Bring the cluster down before copying. It's restarted before we exit
    # the utility.
    gpstop -a -d "$master_datadir"

    cache "$cache" "$master_datadir"

    for seg in "${PRIMARY_ARRAY[@]}"; do
        local seg_datadir="$(datadir $seg)"
        cache "$cache" "$seg_datadir"
    done

    gpstart -a -d "$master_datadir"

    # Mark the cache ready for use.
    touch "$cache/valid"

    log "cached cluster $master_datadir at $cache"
}

restore() {
    local cachedir=$1
    local datadir=$2

    local subdir="$cachedir/$datadir"

    mkdir "$datadir" # fail if it already exists
    cp -pR "$subdir"/ "$datadir"
}

restore_cluster() {
    local inputfile="$1"
    local cache="$2"

    source "$inputfile"

    local master_datadir="$(datadir $QD_PRIMARY_ARRAY)"
    restore "$cache" "$master_datadir"

    for seg in "${PRIMARY_ARRAY[@]}"; do
        local seg_datadir="$(datadir $seg)"
        restore "$cache" "$seg_datadir"
    done

    # Bring the cluster up to match gpinitsystem behavior.
    gpstart -a -d "$master_datadir"

    log "restored $cache to cluster $master_datadir"
}

main() {
    local inputfile=
    local automatic=0

    log "-- $(date)"
    log "called with args: $@"

    while getopts ":aI:-:" opt; do
        case "$opt" in
            a)
                automatic=1
                ;;
            I)
                inputfile="$OPTARG"
                ;;
            -)
                # long option; ignore
                ;;
        esac
    done

    # Compute the arguments hash for this run.
    local hash=
    if [ -z "$HASHPROG" ]; then
        log "not cacheable: no hash program available"
    elif [ -z "$inputfile" ]; then
        log "not cacheable: no -I input file given"
    elif (( ! $automatic )); then
        log "not cacheable: no -a option given"
    else
        # Hash the contents and arguments.
        hash=$(echo "$@" | cat - "$inputfile" | "$HASHPROG" | cut -d' ' -f1)
        log "cache hash: $hash"
    fi

    local dir="$CACHEDIR/cache.$hash"

    if [ -f "$dir/valid" ]; then
        log "cache hit"

        restore_cluster "$inputfile" "$dir"
        exit 0
    fi

    log "cache miss"

    # Run the actual gpinitsystem.
    gpinitsystem.bak "$@" || {
        local err=$?
        log "failed to run gpinitsystem.bak: exit code $err"
        exit $err
    }

    if [ -z "$hash" ]; then
        # We can't cache this run, so we're done.
        log "skipping cache (see above)"
        exit 0
    fi

    cache_cluster "$inputfile" "$dir"
}

main "$@"
